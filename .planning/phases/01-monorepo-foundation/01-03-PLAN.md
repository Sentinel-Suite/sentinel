---
phase: 01-monorepo-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - apps/api/package.json
  - apps/api/src/main.ts
  - apps/api/src/app.module.ts
  - apps/api/src/tracing.ts
  - apps/api/src/health/health.module.ts
  - apps/api/src/health/health.controller.ts
  - apps/api/src/health/indicators/database.health.ts
  - apps/api/src/health/indicators/redis.health.ts
  - apps/api/src/common/middleware/correlation-id.middleware.ts
  - apps/web/package.json
  - apps/web/src/app/page.tsx
  - apps/web/src/app/layout.tsx
  - apps/admin/package.json
  - apps/admin/src/app/page.tsx
  - apps/admin/src/app/layout.tsx
autonomous: true
requirements:
  - INFR-05

must_haves:
  truths:
    - "API requests produce structured JSON logs with correlationId, requestPath, and method"
    - "GET /health returns 200 with status of PostgreSQL and Redis connections"
    - "GET /api/system returns environment info and connected service versions"
    - "pnpm dev starts the API on port 3500, web on port 3501, and admin on port 3502 without errors"
    - "Web and admin landing pages display API connection status (green/red indicator)"
    - "Correlation IDs propagate from request header or are auto-generated as UUIDs"
  artifacts:
    - path: "apps/api/src/main.ts"
      provides: "NestJS bootstrap with Pino logger and OTel SDK"
      contains: "bufferLogs"
    - path: "apps/api/src/tracing.ts"
      provides: "OpenTelemetry SDK initialization"
      contains: "NodeSDK"
    - path: "apps/api/src/health/health.controller.ts"
      provides: "Health check and system info endpoints"
      exports: ["HealthController"]
      contains: "@Get"
    - path: "apps/api/src/health/indicators/database.health.ts"
      provides: "Custom Drizzle database health indicator"
      contains: "HealthIndicator"
    - path: "apps/api/src/health/indicators/redis.health.ts"
      provides: "Redis health indicator"
      contains: "HealthIndicator"
    - path: "apps/web/src/app/page.tsx"
      provides: "Web landing page with API connection status"
      contains: "fetch"
    - path: "apps/admin/src/app/page.tsx"
      provides: "Admin landing page with API connection status"
      contains: "fetch"
  key_links:
    - from: "apps/api/src/main.ts"
      to: "apps/api/src/tracing.ts"
      via: "First import for OTel SDK initialization"
      pattern: "import.*tracing"
    - from: "apps/api/src/app.module.ts"
      to: "nestjs-pino LoggerModule"
      via: "Module import with pinoHttp config"
      pattern: "LoggerModule.forRoot"
    - from: "apps/api/src/health/indicators/database.health.ts"
      to: "@sentinel/db controlDb"
      via: "Drizzle SQL query for health check"
      pattern: "import.*controlDb.*@sentinel/db"
    - from: "apps/web/src/app/page.tsx"
      to: "apps/api /health endpoint"
      via: "fetch call to API health endpoint"
      pattern: "fetch.*health"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/health/health.module.ts"
      via: "Module import"
      pattern: "HealthModule"
---

<objective>
Bootstrap the NestJS API with structured Pino logging, OpenTelemetry tracing, health check endpoints, and a correlation ID middleware. Create Next.js landing pages for web and admin that display API connection status and environment info.

Purpose: Complete the developer experience -- running `pnpm dev` starts all apps, the API produces observable JSON logs, health checks verify infrastructure connectivity, and the frontend confirms the full stack is working.
Output: A fully operational local development environment where `make up && pnpm dev` gives a working system with API, web, admin, PostgreSQL, and Redis all connected and observable.
</objective>

<execution_context>
@/Users/darreljones/.claude/get-shit-done/workflows/execute-plan.md
@/Users/darreljones/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-monorepo-foundation/01-CONTEXT.md
@.planning/phases/01-monorepo-foundation/01-RESEARCH.md
@.planning/phases/01-monorepo-foundation/01-01-SUMMARY.md
@.planning/phases/01-monorepo-foundation/01-02-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs from prior plans. -->

From packages/config/src/env.ts (created in Plan 02):
```typescript
export const env: {
  NODE_ENV: 'development' | 'production' | 'test';
  LOG_LEVEL: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  CONTROL_DATABASE_URL: string;
  REDIS_URL: string;
  API_PORT: number;
  WEB_PORT: number;
  ADMIN_PORT: number;
  OTEL_EXPORTER_OTLP_ENDPOINT?: string;
  LOKI_URL?: string;
  METRICS_PORT: number;
  SENTRY_DSN?: string;
  FLAGSMITH_SERVER_SIDE_KEY?: string;
};
```

From packages/db/src/index.ts (created in Plan 02):
```typescript
export { controlDb } from './client';        // Drizzle instance for control database
export { createTenantDb } from './client';   // Factory for tenant database connections
export { closeConnections } from './client'; // Graceful shutdown
export * from './schema/control';            // systemInfo table schema
```

From packages/shared/src/index.ts (created in Plan 01):
```typescript
export type Result<T, E = AppError> = { ok: true; value: T } | { ok: false; error: E };
export function ok<T>(value: T): Result<T, never>;
export function err<E>(error: E): Result<never, E>;
export class AppError extends Error { code: string; statusCode: number; }
export class NotFoundError extends AppError { /* 404 */ }
export class ValidationError extends AppError { /* 400 */ }
export class UnauthorizedError extends AppError { /* 401 */ }
export class ForbiddenError extends AppError { /* 403 */ }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bootstrap NestJS API with Pino logging, OpenTelemetry tracing, and health endpoints</name>
  <files>
    apps/api/package.json,
    apps/api/src/tracing.ts, apps/api/src/main.ts, apps/api/src/app.module.ts,
    apps/api/src/health/health.module.ts, apps/api/src/health/health.controller.ts,
    apps/api/src/health/indicators/database.health.ts, apps/api/src/health/indicators/redis.health.ts,
    apps/api/src/common/middleware/correlation-id.middleware.ts
  </files>
  <action>
    **Add dependencies to apps/api/package.json:**
    Runtime: nestjs-pino, pino, pino-http, @nestjs/terminus, @opentelemetry/sdk-node, @opentelemetry/auto-instrumentations-node, @opentelemetry/exporter-trace-otlp-http, @opentelemetry/exporter-prometheus, @opentelemetry/resources, @opentelemetry/semantic-conventions, nestjs-otel, pino-loki, ioredis.
    DevDependencies: pino-pretty, @types/express.
    Run `pnpm install --filter @sentinel/api`.

    **OpenTelemetry SDK (apps/api/src/tracing.ts):**
    Per research Pattern 7 -- MUST be loaded before any NestJS imports.
    - Create NodeSDK with:
      - resource: service.name = 'sentinel-api'
      - traceExporter: OTLPTraceExporter pointing to env var OTEL_EXPORTER_OTLP_ENDPOINT or http://localhost:4318/v1/traces
      - metricReader: PrometheusExporter on METRICS_PORT (9464)
      - instrumentations: getNodeAutoInstrumentations()
    - Call sdk.start()
    - Register SIGTERM handler for sdk.shutdown()
    - IMPORTANT: This file reads process.env directly (NOT @sentinel/config) because it must execute before any other imports. The env vars it needs (OTEL_EXPORTER_OTLP_ENDPOINT, METRICS_PORT) have safe defaults.

    **NestJS Bootstrap (apps/api/src/main.ts):**
    - FIRST LINE: `import './tracing';` (per research Pitfall 3 -- OTel must init before everything else)
    - Import NestFactory, AppModule, Logger from nestjs-pino
    - Import env from @sentinel/config
    - Create app with `{ bufferLogs: true }` (per research Pitfall 7)
    - Set global prefix: `app.setGlobalPrefix('api')`
    - Enable CORS (for web/admin apps to call API)
    - Use Pino logger: `app.useLogger(app.get(Logger))`
    - Listen on `env.API_PORT`
    - Log startup message with port

    **AppModule (apps/api/src/app.module.ts):**
    - Import LoggerModule from nestjs-pino, configured per research Pattern 2:
      ```
      LoggerModule.forRoot({
        pinoHttp: {
          level: env.LOG_LEVEL,
          transport: env.NODE_ENV !== 'production'
            ? { target: 'pino-pretty', options: { colorize: true, singleLine: true } }
            : undefined,
          genReqId: (req) => req.headers['x-correlation-id'] || crypto.randomUUID(),
          customProps: (req) => ({
            correlationId: req.id,
          }),
        },
      })
      ```
    - Import HealthModule
    - Import OtelModule from nestjs-otel (for Prometheus metrics decorators)

    **Health Module (apps/api/src/health/):**

    `health.module.ts`:
    - NestJS module importing TerminusModule, providing HealthController, DatabaseHealthIndicator, RedisHealthIndicator.

    `health.controller.ts`:
    - Two endpoints:
      1. `GET /health` -- HealthCheck using @nestjs/terminus. Checks: database (custom Drizzle indicator), Redis (custom indicator), memory heap (150MB limit). Returns standard terminus format: `{ status: 'ok', info: {...}, error: {...}, details: {...} }`.
      2. `GET /api/system` -- Returns JSON: `{ environment: env.NODE_ENV, version: '0.0.0', uptime: process.uptime(), services: { postgres: 'connected'|'disconnected', redis: 'connected'|'disconnected' }, ports: { api: env.API_PORT, web: env.WEB_PORT, admin: env.ADMIN_PORT } }`. Catches errors gracefully.

    `indicators/database.health.ts`:
    - Custom HealthIndicator extending @nestjs/terminus HealthIndicator.
    - Injects nothing directly -- imports controlDb from @sentinel/db.
    - Health check: Execute `SELECT 1` via controlDb (use `sql` tagged template from drizzle-orm: `import { sql } from 'drizzle-orm'; await controlDb.execute(sql\`SELECT 1\`);`).
    - Returns `this.getStatus('database', true)` on success, `this.getStatus('database', false, { error: e.message })` on failure.

    `indicators/redis.health.ts`:
    - Custom HealthIndicator using ioredis.
    - Creates Redis client from env.REDIS_URL.
    - Health check: `await redis.ping()`.
    - Returns healthy/unhealthy status.
    - Handles connection errors gracefully (returns unhealthy, not crash).

    **Correlation ID Middleware (apps/api/src/common/middleware/correlation-id.middleware.ts):**
    - NestJS middleware that checks for `x-correlation-id` header.
    - If absent, generates a UUID and sets it on the request AND response headers.
    - This ensures downstream services and clients can trace requests.
    - Register in AppModule via `configure(consumer)` applying to all routes.

    After all files are created, run `pnpm install` and verify compilation: `pnpm --filter @sentinel/api exec tsc --noEmit`.
  </action>
  <verify>
    <automated>cd /Users/darreljones/Development/sentinel-suite && pnpm install && pnpm --filter @sentinel/api exec tsc --noEmit && echo "API compilation passed"</automated>
  </verify>
  <done>
    NestJS API bootstraps with Pino structured logging (JSON in production, pretty in dev). OpenTelemetry SDK initializes before NestJS for full auto-instrumentation. GET /health returns terminus-format health status for database and Redis. GET /api/system returns environment info. Correlation IDs are generated or propagated on every request. All logs include correlationId field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js landing pages for web and admin with API connection status</name>
  <files>
    apps/web/src/app/page.tsx, apps/web/src/app/layout.tsx, apps/web/package.json,
    apps/admin/src/app/page.tsx, apps/admin/src/app/layout.tsx, apps/admin/package.json
  </files>
  <action>
    **Web Landing Page (apps/web/src/app/page.tsx):**

    Create a landing page that shows:
    1. App name: "Sentinel Suite" as the main heading
    2. Subtitle: "Security Operations Platform"
    3. API Connection Status: A colored indicator (green circle + "Connected" / red circle + "Disconnected") based on fetching the API health endpoint.
    4. Environment Info: Display NODE_ENV, API URL being used.
    5. Connected Services: Show PostgreSQL and Redis status from the /api/system response.
    6. Port Info: Display what ports the apps are running on.

    Implementation:
    - Use a client component (`'use client'`) for the status-fetching logic.
    - On mount, fetch `http://localhost:${API_PORT}/health` (use environment variable or hardcode 3500 for dev).
    - Display loading state while fetching, then show connected/disconnected.
    - Use Tailwind CSS for styling: centered layout, card-based sections, status badges with colored dots.
    - Handle fetch errors gracefully (show "Disconnected" with error message, not a crash).
    - Keep it clean and minimal -- this is a dev dashboard, not a production UI.

    **Update apps/web/src/app/layout.tsx:**
    - Add proper metadata: title "Sentinel Suite", description "Security Operations Platform".
    - Import and apply a basic sans-serif font via Tailwind.
    - Set body class for Tailwind: `className="min-h-screen bg-gray-50 antialiased"`.

    **Admin Landing Page (apps/admin/src/app/page.tsx):**
    - Same structure as web but:
      - Heading: "Sentinel Suite - Admin Console"
      - Subtitle: "System Administration"
      - Same API health check and service status display
      - Add a "This is the admin dashboard" indicator to distinguish from web app

    **Update apps/admin/src/app/layout.tsx:**
    - Metadata: title "Sentinel Suite - Admin", description "System Administration Console".
    - Same Tailwind body styling.

    **Note on API URL:** For dev convenience, the API URL should be configurable. Use `process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3500'` so it works both with and without Traefik. Add NEXT_PUBLIC_API_URL to .env.example.

    Add NEXT_PUBLIC_API_URL to .env.example with default http://localhost:3500 and a comment explaining it's for the frontend apps.

    Verify both pages render: `pnpm --filter @sentinel/web exec next build` and `pnpm --filter @sentinel/admin exec next build` (builds should succeed even without API running -- the status will just show "Disconnected").
  </action>
  <verify>
    <automated>cd /Users/darreljones/Development/sentinel-suite && pnpm --filter @sentinel/web exec next build && pnpm --filter @sentinel/admin exec next build && echo "Frontend builds passed"</automated>
  </verify>
  <done>
    Web app landing page displays "Sentinel Suite" with API connection status indicator, environment info, and connected services. Admin app landing page displays "Sentinel Suite - Admin Console" with same status features. Both apps build successfully. Pages handle API being unavailable gracefully (show "Disconnected" state). Tailwind CSS styling is applied.
  </done>
</task>

</tasks>

<verification>
1. `pnpm dev` starts API (3500), web (3501), and admin (3502) without errors
2. `curl http://localhost:3500/health` returns JSON with database and Redis status
3. `curl http://localhost:3500/api/system` returns environment info
4. API logs are structured JSON with correlationId field (in production mode) or pretty-printed (in dev mode)
5. Sending `x-correlation-id: test-123` header propagates to response and logs
6. Web app at localhost:3501 shows API connection status
7. Admin app at localhost:3502 shows API connection status
8. Both frontends handle API being down gracefully (no crash, shows disconnected)
</verification>

<success_criteria>
- NestJS API boots with Pino structured logging and OpenTelemetry tracing
- Health endpoint verifies PostgreSQL and Redis connectivity
- System info endpoint returns environment and service details
- Correlation IDs are auto-generated or propagated from request headers
- Web and admin landing pages show real-time API connection status
- `pnpm dev` starts all three functional apps concurrently
- The full developer flow works: `make up && pnpm dev` -> visit localhost:3501 -> see green status indicators
</success_criteria>

<output>
After completion, create `.planning/phases/01-monorepo-foundation/01-03-SUMMARY.md`
</output>
